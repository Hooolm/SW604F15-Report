%!TEX root = ../../../super_main.tex

\section{Memory Issues}
\label{sec:memory_issues}

The main purpose of the \ct is to manage and thereby display, add, and edit pictogram categories. We have to display series of pictograms in order to manage categories meaningfully. This caused some trouble because of the way the database components of the project are implemented. All database data abstraction classes that includes a bitmap, at the time of the third sprint, inherited from a class called \androidinline{BasicImageModel}. The problem with this class is that it lazy loads its bitmap and saves a reference to it until the \androidinline{BasicImageModel} itself is deallocated. The problem is then that we want to display potentially hundreds of pictograms, a few at a time, in a scrollable grid, i.e. an Android \androidinline{GridView}, on a device with a very limited amount of RAM. It may be that modern android devices pack up to several gigabytes of RAM, but that does not mean that all of this RAM is available to all applications. In fact Android limits the heap size of each application to some device dependent limit as stated in the official Android application development memory guide \parencite{android_memory}. The guide text also recommends that applications only keep bitmaps in memory as long as they are currently shown on current screen of the graphical user interface. The memory limit forces us to only keep a very limited amount bitmaps in memory at any one time, compared to for instance a desktop environment where the virtual memory system will just page out bitmaps that were not used for some time. 

\subsection{Workaround}
\label{subsec:pictogram_workaround}

The database groups have been informed about the issue and we suggested a solution: Remove all references to the bitmaps kept by the \androidinline{BasicImageModel} and let the clients of the \androidinline{BasicImageModel} subclasses maintain the bitmap references. The database groups are working on a solution as of the end of sprint 3. \\

In order to make the \ct application work for the third sprint end, we implemented a workaround which allowed us to manage the references to bitmaps in the application code and not in the database abstraction code. \\

The workaround was implemented using Trail: The Reflection API in Java \parencite{java_trail_reflection}. What we did was make a deep copy of the \androidinline{BasicImageModel} object we want to display. We then load the bitmap, keeping a reference to it which we will manage ourself, from the deep copy of our object. The deep copy is then thrown away, insuring that we only have one reference to the bitmap.

\subsection{Android Adapters}

As described in \secref{sec:implementation_of_new_design} we use a combination of \androidinline{ListView} and \androidinline{Adapter} to display a list of items. \\

The Android framework provides a series of classes implementing an interface called \androidinline{Adapter} which makes it easy to map between collections of data and views. For instance when displaying a list of items in a \androidinline{ListView} which is a subclass of \androidinline{AdapterView}, or like in our case a scrolling grid of items in another subclass of \androidinline{AdapterView} called \androidinline{GridView}. A \androidinline{GridView} creates a scrollable grid of views, where the views are provided by its adapter. The \androidinline{AdapterView} subclasses all maintain a collection of views currently displayed plus some extras corresponding, in the case of the \androidinline{GridView}, to the next and previous row of views. \\

The views for the next row of data item is then generated by the adapter of the \androidinline{GridView} when the \androidinline{GridView} is scrolled to the next row of items by the user. The \androidinline{GridView} calls the \androidinline{Adapter} instance's \androidinline{getView} method once for each data item it wants to display each with the index, as an argument, of the desired data item. \\

The \androidinline{getView} method takes three arguments where one of them is called \androidinline{convertView} which is an instance of a previously discarded view corresponding to a data item that no longer needs to be displayed. This allows for reuse of the views so that the \androidinline{getView} does not need to create a new instance of a view every time it is called. Instead the \androidinline{getView} method implementation can simply reuse the \androidinline{convertView} \androidinline{View} instance and then load the relevant properties, for the data item at the calling index, in order to set them on the recycled view object. \\

All this together guarantees that there will only be up to some relatively small constant number of views, for the potentially large number of data items, in memory at any one time. If we let these views be the only objects keeping references to bitmaps, one reference per view, we would then be guaranteed to keep only a small constant number of bitmaps in memory at the same time assuming that the garbage collector can manage to free the memory fast enough when we load new bitmaps in and override the old bitmap references on the views. 

\subsection{GirafPictogramItemView}
We packed our temporary solution, i.e our workaround from \secref{subsec:pictogram_workaround}, in a nice way to display pictograms called \androidinline{GirafPictogramItemView}. One should in general no longer experience memory issues related to pictogram bitmaps as long as one uses \androidinline{GirafPictogramItemView} objects to display the pictograms managed by an Android \androidinline{Adapter} and as long as they do not attempt to display too many pictograms at once. \androidinline{GirafPictogramItemView} is a simple layout with an \androidinline{ImageView} at its core that lazy loads its bitmap on a background thread.   

\todo{Inds√¶t screen shot af GirafPictogramItemView}